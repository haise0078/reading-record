## Java

### クラス設計

* カプセル化によって、データと処理を一つのクラスにまとめて凝集度の高いクラスを設計する。
メソッドはクラスがもつデータを利用するようにする。
* オブジェクトの値を更新するのではなく、新しくオブジェクトを作成することで、オブジェクトを極力イミュータブルに設計する。

* 値の種類でクラスを分けると、DRYで凝集度の高いクラス設計になる。
クラス化する効果が高いのは、ロジックの複雑さや使用頻度が高いもの。
* 設計を分かりやすくするために、多目的なメソッドは作成しない。

* 値の分類にしたがって基本的なクラスを作成し、それを組み合わせて利用するクラスを実装してアプリケーションを組み立てる。

### インターフェイスの使い方

* ジェネリクス型は汎用的なクラスやインターフェイスを実装する際に用いる。
アプリケーション固有の用途限定のクラスを設計する場合には、ジェネリクス型はむやみに使用しない方が良い。

## 継承

* 継承を多用すると、変更の影響範囲が特定しずらくなる。できるだけ継承以外の方法を利用する。

* 継承以外のコードを再利用する方法として、他のクラスのオブジェクトを部品として利用するコンポジションという構造がある。
* 一時的にオブジェクトを生成して、処理の中で使い捨てるという方法もある。
複雑なメソッドをリファクタする際に、まずはプライベートメソッドに切り出し、プライベートメソッドがクラスのフィールドを参照していなければ更にクラスに切り出すことが可能。

* 列挙型は単に定数の組み合わせを定義するだけでなく、その組み合わせを用いた判断や計算のロジックをenumに実装できる。

## WASM

### WASMとは

* ブラウザ上で実行することを目的としたバイナリファイルの形式のひとつ。
WATをコンパイルしてWASMにできる。
* WASMはJavaScriptを置き換えるものではない。
ブラウザにランタイムが含まれることや、ブラウザへのAPIに直接アクセス可能なことなどJSの優位性は変わらない。
公式ではWASMがコアのロジックを担当し、JSがGUIとの橋渡しになるという想定。
* WASMの優位性は、実行時の最適化が少ないため実行開始が早く実行速度が安定している点。
あと、JS以外の言語で書かれたライブラリの移行も重要なテーマである。

* wasm-packを使って、wasmのモジュールがJSでインポート可能にできる。

### WASMによってユーザー体験がどう変わるのか

* クライアント側に最適化する処理をサーバーに集中させることなく、分散できる。
動画配信で言えば画質の切り替えや、サイズの変更など。

* サーバーとの通信が必要な処理をクライアントに任せることができるようになればPWAの可能性が広がる。

### ブラウザ外のwasm

* 「wasmがブラウザで実行される」というのは、ブラウザがWasmのVMを実装して実行環境を提供しているということ。
* Import Sectionで外部から提供されるリソースをVMに取り込み、export sectionでVMで定義した関数を外部で実行可能にする。
ホスト環境側で定義した関数をWasmにリンクした際のオブジェクトをHost functionと呼ぶ。
* WASIというインターフェイス仕様を策定したことで、ホスト環境ごとの開発が統一された。
* K8sのコンテナをWASMとWASIで実装するKrustletという試みも進められている。
