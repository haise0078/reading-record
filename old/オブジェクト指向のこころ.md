# オブジェクト指向ソフトウェア開発入門
##  1章 オブジェクト指向パラダイム
### ポイント
- 凝集度と結合度

凝集度はあるルーチン内の演算の関連の強さを表す
結合度はあるルーチンと他のルーチンの関連の強さを表す


- ソフトウェア開発プロセスの観点
リクエストする側は概念を知っておき、仕様にしたがってリクエストすれば良い
    - 概念
    何に対する責任を持つのか
    - 仕様
    どのように使用されるのか
    - 実装
    どのようにして責任を全うするのか


- 抽象クラス
抽象クラスは実体化できないだけではなく、それが表現する概念を具体化したクラスの実装を格納する場所を提供する


### 練習問題

1. 機能分解の基本的なアプローチ
手順を詳細に分解してモジュール化する

2. 要求の変更
ユーザーが新たな可能性に気づく
開発側の理解が深まり、考え方が変わる
環境が変化する

- 3. 責任に着目することの意味
責任に着目することで、リクエストを出す際には責任を知っておけばよく、実装をカプセル化できる

- 4. 結合度と凝縮度の定義
ポイントに書いた

- 5. インターフェイスの目的
他のオブジェクトに利用方法を提示する、同じ概念を持つオブジェクトの仕様を共通化する

- 6. インスタンスの定義
そのクラスの型に従い作成される新規オブジェクト

- 7. オブジェクトが定義する三つの観点
概念、仕様、実装

- 8. 抽象クラスとは？
ポイントに書いた

- 9. オブジェクトが保持できるアクセス可能性
public, protected, private

- 10. カプセル化の定義
データや実装など、あらゆる種類の隠蔽

- 11. ポリモーフィズム
同一の仕様に沿った呼び出し方法で、異なる実装のクラスを呼び出し振る舞いを変えること

- 12. オブジェクトを考える際の三つの観点
概念、仕様、実装
7との違いが不明


# 2章 クラス図

## ポイント
- クラスの関係
    - 継承（is a 関係）
    ある抽象クラスAから派生したBは　B is A という継承関係にある
    - 集約（has a 関係）
    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成しない場合
    - コンポジション（has a 関係）
    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成する場合
    - 依存（use a　関係）
    あるオブジェクトが別のオブジェクトを使用する関係

## 練習問題

1. 関係
ポイントにまとめた

2. クラス表現の3つの内容
名称、データメンバ、メソッド

3. ガーディナリティ
いくつ保持するかを表す

4. シーケンス図の目的
オブジェクト間の動的なやり取りを時系列で可視化して定義すること


# 5章
## 練習問題
3. パターンの定義
優れた設計に存在する類似点

5. デザインパターンを学習する理由
- 解決策の再利用
- 共通用語の確率

6. 優れたオブジェクト指向を生み出す戦略
- インターフェイスを用いて設計する
- 継承よりも集約を使用する
- 流動的要素をカプセル化する

# 6章 Facadeパターン
## ポイント
- Facadeパターンとは
何らかの機能を実現するシステムの部分集合のみが必要となる場合、そう言ったやり取りの方法だけを取り出したものを作る
既存システムのフロントエンドとして新たなインターフェイスを置くこと


## 練習問題
- Facadeの定義
既存のシステムの一部の機能を提供するインターフェイス

- Facadeパターンの目的
    - 既存のシステムをカプセル化すること
    - 既存のシステムに影響を与えずに追加機能を実装すること

- Facadeパターンの因果関係
要求されたサブシステムの使用方法（インターフェイス）を簡略化するが、そのためある種の機能がクライアントから利用できない可能性がある


# 7章 Adapterパターン
## ポイント
- Adapterパターンとは
オブジェクトの動作は望み通りだが、インターフェイスが望み通りではない場合に、別のインターフェイスを用意すること

システムの中には複数のオブジェクトを持ち込むが、それらのオブジェクトとは共通の方法でやり取りを可能にしたい場合（ポリモーフィズムを実現したい場合）に有効


## 練習問題

- Adapter
オブジェクトの動作は望み通りだが、インターフェイスが望み通りではない場合に、別のインターフェイスを用意すること

- Adapterパターンの目的
インターフェイスを変換し、既存の設定に適合させること

- Adapterパターンの因果関係
既存オブジェクトを新たなクラス構造に取り込む際に、そのインターフェイスの制限に適合できる

- ShapeとPoint, Line, Squareの関係を定義するオブジェクト指向の概念
ポリモーフィズム

- Adapterパターンのもっとも一般的な使用法
既存オブジェクトの取り込み

- Adapterパターンによって意識しなくてもよくなること
クライアントオブジェクトは、実際に存在している型を意識する必要がなくなる

- 2種類のAdapterパターン

Object Adapterパターン
Class Adapterパターン（よくわからない）


# 8章 視野を広げる
## ポイント
- オブジェクト
    - 実装の観点からみると、オブジェクトは操作を伴うデータと言える
    - 概念の観点からみると、オブジェクトは責務を備えた実体であると言える
    - 実装をインターフェイスの背後に隠して、自分の責務以外の部分を隠蔽する
- カプセル化
カプセル化ではデータだけではなく以下のものも隠蔽できる
    - 実装
    - 派生クラス
    - 設計の詳細
    - 実体化の規則

- 流動的要素を見つけ出し、それをカプセル化する

データが流動的になる場合は、そのデータを保持するデータメンバを作成して、セッターとゲッターを用意する

メソッドが流動的になる場合は、振る舞いにおける流動的な要素をオブジェクトに保持させて参照する

- 共通性/可変性分析と抽象クラス
共通性/可変性分析によって、問題領域のどこが流動的要素となるのかを識別できる
これによりオブジェクトの洗い出しが従来よりも効率的に実施できる
    - 共通性分析
    互いに関連のある要素の共通性に着目して、それらの要素が所属するファミリを定義する
    - 可変性分析
    特定の共通性の中で要素がどのように違っているのかを定義する

## 練習問題
- カプセル化についての正しい認識
カプセル化ではデータだけではなく以下のものも隠蔽できる
    - 実装
    - 派生クラス
    - 設計の詳細
    - 実体化の規則

- 問題領域をみる際の三つの観点
    - 概念の観点
    - 仕様の観点
    - 実装の観点
    
# 9章 Strategyパターン
## ポイント
- より効率的なオブジェクト指向
再利用のためのオブジェクト指向では、継承関係の階層が深くなってしまう

これを防ぐために、
1. 流動的要素を探し出し、それ自体をクラスにカプセル化する
2. このクラスを他のクラスに保持させる

これにより、流動的要素を取り扱うオブジェクトを保持しているオブジェクトは流動的要素がどのようにして処理されているかを意識する必要がなくなる


## 練習問題

- 新たな要求を取り扱う方法
流動的要素を探し出してカプセル化する

- GoFが提唱する変更に取り組む際の三つの原則
    - 実装を用いるのではなく、インターフェイスを用いてプログラミングする
    - 継承よりも集約を多用する
    - 再設計せずに変更可能にするものを考える、つまりは流動的要素のカプセル化に着目する

- Strategyパターンの目的
共通のアルゴリズムを、それを使用するコンテキストに応じて使い分けられるようにすること

- Stratrgyパターンの因果関係
    - 条件分岐をなくすことができる
    - 全てのアルゴリズムは同じ方法で起動されなくてはならない

# 9章 ブリッジパターン

## ポイント
- Bridgeパターンのパワー
問題領域に存在している実装をいつ抽象化すべきなのかを教えてくれる点

## 練習問題
- 「切り出す」の定義
ものごとが互いに独立して振る舞えるようにする
もしくは、少なくともそれらの関係を明確に述べることを指す

- 「抽象的側面」の定義
ものごとの概念的な側面

- Bridgeパターンのコンテキストにおける実装の定義
抽象クラスとその派生物が自らを実装するために必要とするもの（抽象クラスの派生物つまり、具象クラスのことではない）

- シーケンス図の基本要素
オブジェクトとオブジェクト間でのメッセージのやり取り

- 共通性分析と可変性分析で洗い出そうとするもの
共通性分析で流動的要素を洗い出し、可変性分析で流動的要素の表現（実装）を洗い出す

- Bridgeパターンが解決する問題

問題領域に存在している実装をいつ抽象化すべきなのかを教えてくれる

これにより、クラス数の爆発を招くことなく、抽象クラスの派生物から複数の実装を使用することができる

- 「一つの場所には一つの規則」
業務上の規則が複数の場所で重複することを防ぐ

- Bridgeパターンの因果関係
オブジェクトが使用する実装をオブジェクトから切り離すことによって拡張性を高める
クライアントオブジェクトは実装について意識しなくてよくなる

# 10章 Abstract Factoryパターン
## ポイント
- Abstract Factoryとは
ポリモーフィズムを実現する際に、適切な具象クラスを生成する方法

オブジェクトの生成とオブジェクトの使用を分離する

## 練習問題

- デバイスドライバの例で起きる問題
オブジェクトの使用と生成が高い結合度で実装される
オブジェクトの使用と生成を分離する必要がある

- Abstract Factoryと呼ばれる理由

オブジェクトの共通部品を具象クラスを指定せずに（Abstract）生成する（Factory）

- Abstract Factoryの三つの概念的手順
1. 実体化の規則を洗い出し、抽象クラスを定義し、実体化する必要のあるオブジェクトごとにメソッドのインターフェイスを定義する

2. 抽象クラスから、ファミリ毎に具象クラスを実装する

3. クライアントオブジェクトがファクトリオブジェクトを使用する

- Abstract FactoryとConcrete Factory
Abstract Factoryは生成規則にしたがって、生成するオブジェクトを決定する
Concrete Factoryは実際に具象クラスを生成する

- Abstract Factoryの因果関係
どのオブジェクトを使用するかの規則と、そのオブジェクトの使用方法を切り離すことができる

# 12章 エキスパートはどのように設計するのか？

## ポイント
- 多くの場合、設計は部分から全体へ、つまり既知のものから具体的なものへと進めていく
しかし、Alexanderは全体から見た位置付けに応じて各部品を修正するプロセスが必要不可欠だと述べている

- Alexanderの設計は建築の世界での理論なので、ソフトウェア設計の世界にそのまま適用できるとは限らない（特にコンテキストの部分）

## 練習問題
- 活き活きした場所
堅牢で柔軟なシステム

- 優れた設計のために念頭に置く必要があるもの
全体像

- 設計を行うための「複雑化」
まずは概念レベルで問題を捉え、その後機能を追加しながら設計を具体化していくプロセス

- パターンは何の関係を定義する？
問題領域における実体間の関係

- Alexanderの設計手順
1. 達成目標を理解するために、全体の概念を理解する
2. 全体に存在するパターンを洗い出す
3. 他のパターンのためのコンテキストを作り出すパターンから一つずつ適用する
4. コンテキスト内にパターンを適用し、新たなパターンを洗い出すことを繰り返す

# 13章 パターンで考える
## ポイント
- コンテキストによる考え方
2つのパターンを考察する場合に、パターンの「メタ」な概念を用いることで、どちらが他方のコンテキストを生み出すのか判断できるようになる


## 練習問題

- パターンを用いたソフトウェア設計の三つの手順
1. 問題領域からパターンを洗い出す
2. 洗い出したパターンを元に実装する
    - パターンの並べ替え
    - パターンの選択
    - 追加のパターン洗い出し
3. 詳細の設計

- コンテキストの定義
何らかのものをその中に存在させる、または発生させる、互いに関連し合う条件、すなわち環境や設定のこと

- 最年長のパターン
システム内に存在し、他のパターンのためのコンテキストを構築する、1つまたは2つのパターンを指す

# 14章 デザインパターンの原則と戦略
## ポイント
- 依存性の逆転原則
オブジェクトを使用する側とされる側の結合は概念レベルで行われるべき

## 練習問題
- 設計の実装方法


- デザインパターンの落とし穴
    - 表層的理解
    - 思い込み
    パターンを信頼しすぎて、選択したパターンで全ての状況を解釈しようとする
    - 選択ミス
    パターンが適切となるコンテキストや状況を理解していない。
    - 誤診
    - 当てはめ
    パターンに当てはめるために、現実に存在する具体的な実体の例外を無視してしまう

# 15章

## 練習問題
- 共通性・可変性を導くための二つのアプローチ
    - どういった概念が存在するかを理解したのち、それらをできるだけ凝集した形で組織化する
    - 問題領域から2つの言葉を任意に選択して以下の質問をする
        - いずれかは、もう一方の流動的要素なのか
        - これらはいずれも、何か他のものの流動的要素なのか

# 16章 分析マトリクス
## 練習問題
- 分析マトリクスにおける左端の列は何を表す？
設計における概念
- 分析マトリクスにおける行は何を表す？
概念を実装する方法
- 分析マトリクスにおける列は何を表す？
その列が表現しているケースに対して使用することになる特定の実装
- 分析マトリクスで表現されるパターン
ポリモーフィズムを表現するパターン全て

# 17章 Decoratorパターン
## ポイント
- Decoratorパターン
Decoratorパターンはオブジェクトに対して新たな責務を動的に付加する。
Decoratorオブジェクトの連鎖によって、必要な機能を必要な順番で連結することが可能になる。

- Decoratorの隠蔽
Decoratorパターンが実力を発揮するためには、オブジェクトの連鎖を実体化する部分は隠蔽される必要があるため、ファクトリオブジェクトを使用することになる

## 練習問題
- Decoratorオブジェクトが包み込むもの
動的に連鎖するオブジェクト

- デコレータの例
カスタム応募フォーム

# 18章 Observerパターン

## ポイント
- Observerパターンの目的
オブジェクト間に一対多の依存関係を定義し、あるオブジェクトの状態が変化した際、それに依存する全てのオブジェクトに対して自動的に通知、更新が行われるようにする

- オブザーバ（通知を受けるオブジェクト）は共通のインターフェイスをもつ

- 依存関係が常に決まっている場合はオブザーバーパターンを使用すると、解決策が複雑化することになる


## 練習問題
- GoFによる構造に関するパターンの責務
既存の機能群をまとめること

- パターンのカテゴリ
    - 生成
    オブジェクトの生成と実体化
    - 構造
    既存オブジェクトをまとめる
    - 振る舞い
    柔軟な振る舞いを実現する
    - 分割
    オブジェクト群を切り分ける

- 要求の持つ絶対的な性質
時間とともに変化すること

- Observerパターンの目的
オブジェクト間に一対多の依存関係を定義し、あるオブジェクトの状態が変化した際、それに依存する全てのオブジェクトに対して自動的に通知、更新が行われるようにする

# 19章 Template Methodパターン

## ポイント
- Template methodパターンの目的
複数の手続きの中で共通して存在する処理を共通化する

## 練習問題

- Template methodパターンによるメソッド呼び出し

処理の一連の流れと共通処理を実装したTemplateMethodを用意する
共通でない処理については、Template Methodの派生クラスのメソッドをTemplate methodが呼び出すことで実行する

# 20章 生成に関するパターン

## ポイント
- オブジェクトは他のオブジェクトを生成および/あるいは管理するか、他のオブジェクトを使用するかのどちらかのみを行い、双方を行ってはいけない

## 練習問題
- ファクトリの定義
他のオブジェクトを実体化するために使用されるメソッド、オブジェクト、それ以外のもの全て

- オブジェクトの生成、管理が必要となった際に使用する一般規則
オブジェクトは他のオブジェクトを生成および/あるいは管理するか、他のオブジェクトを使用するかのどちらかのみを行い、双方を行ってはいけない

# 21章 singletonパターンとDouble-Checked Lockingパターン
- Singletonとは
生成のパターンで、オブジェクトを最大一つしか実体化しない場合に使用する
- Singletonパターンの目的
オブジェクトの実体が単一となることを保証する
- singletonがオブジェクトを生成するために使用する特殊なメソッド
コンストラクタをprivateにし、代わりにインスタンスを返すメソッドを用意する

# 22章 Object Poolパターン

## 練習問題

- 設計時に従うべき3つの戦略

- Object Pool パターンに組み込まれている2つのパターン
Singletonパターン
Factoryパターン
- Object Poolパターンの目的
オブジェクトの生成だけでなく、管理にもファクトリを使用し、責務をカプセル化すること

# 23章 Factory Methodパターン

## 練習問題
- ファクトリの責務
オブジェクトの実体化と管理

- Factory Methodを利用する本質的な理由
実体化に関する決定をサブクラスの実装まで保留することによるカプセル化

# 25章 総括と今後
## パターンの本質
- パターンはカプセル化によって実装を隠蔽できる
- パターンは共通性を洗い出せる
- パターンは責務によるオブジェクトの分解を手助けする
- パターンはオブジェクト間の関連を規定できる
- パターンはコンテキストに基づく設計を具体化できる
