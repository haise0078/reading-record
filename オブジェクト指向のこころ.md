## 1部 オブジェクト指向ソフトウェア開発入門

### 1章 オブジェクト指向パラダイム

* 機能分解によってメインプログラムの責務が大きくなりすぎることを防ぐために、委譲という考え方を用いる。
委譲とは、実行指示をすれば各々が責務にしたがって振る舞うこと。
* 機能分解によってモジュール化されたソフトウェアは凝集度が低く、結合度が高くなる。
結果、要求の変化に対応する際のコストが増大し、バグが生み出されやすくなる。
* カプセル化は単にデータの隠蔽ではなく、実装や具象クラスの型などあらゆる種類の隠蔽である。
カプセル化は結合度を下げることに繋がり、実装側と呼び出し側を切り離して修正できるようになる。
* ポリモーフィズムを実現することで、柔軟なソフトウェアを構築できる。

#### 練習問題

1. 機能分解の基本的なアプローチ：手順を詳細に分解してモジュール化する
2. 要求の変更：

    * ユーザーが新たな可能性に気づく
    * 開発側の理解が深まり、考え方が変わる
    * 環境が変化する

3. 責任に着目することの意味：責任に着目することで、リクエストを出す際には責任を知っておけばよく、実装をカプセル化できる
4. 結合度と凝縮度の定義：

    * 凝集度はあるルーチン内の演算の関連の強さを表す
    * 結合度はあるルーチンと他のルーチンの関連の強さを表す

5. インターフェイスの目的：他のオブジェクトに利用方法を提示する、同じ概念を持つオブジェクトの仕様を共通化する
6. インスタンスの定義：そのクラスの型に従い作成される新規オブジェクト
7. オブジェクトが定義する三つの観点：

    * 概念：何に対する責任を持つのか
    * 仕様：どのように使用されるのか
    * 実装：どのようにして責任を全うするのか

8. 抽象クラスとは？：抽象クラスは実体化できないだけではなく、それが表現する概念を具体化したクラスの実装を格納する場所を提供する
9. オブジェクトが保持できるアクセス可能性：public, protected, private
10. カプセル化の定義：データや実装など、あらゆる種類の隠蔽
11. ポリモーフィズム：同一の仕様に沿った呼び出し方法で、異なる実装のクラスを呼び出し振る舞いを変えること
12. オブジェクトを考える際の三つの観点：概念、仕様、実装

### 2章 UML統一モデリング言語

クラスの関係は以下の通り。

* 継承（is a 関係）

    ある抽象クラスAから派生したBは　B is A という継承関係にある。

* 集約（has a 関係）
    
    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成しない場合。

* コンポジション（has a 関係）

    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成する場合。

* 依存（use a 関係）
  
    あるオブジェクトが別のオブジェクトを使用する関係。

## 練習問題

1. 関係：省略
2. クラス表現の3つの内容：名称、データメンバ、メソッド
3. ガーディナリティ：いくつ保持するかを表す
4. シーケンス図の目的：オブジェクト間の動的なやり取りを時系列で可視化して定義すること

## 2部 従来のオブジェクト指向設計における限界

### 3章

エキスパートシステムが異なるバージョンのCAD/CAMシステムに対応できるようにする必要があった。

### 4章

あらゆるケースを特殊化するアプローチで、問題を解決することは可能である。
しかしこの設計は冗長度が高く、凝集度が低く、将来の変更時にクラス数が爆発するという欠点がある。

## 3部 デザインパターン

### 5章 デザインパターンの紹介

デザインパターンを学習することで下記のメリットがある。

* 解決策の再利用：すでに確立されている設計を再利用することで、問題解決に向けて幸先のようスタートを切ることができる。
* 共通用語の確立：コミュニケーションを円滑にするために、問題に対する共通のボキャブラリと認識を保つことができる。

優れたオブジェクト指向設計を生み出すための戦略として下記が示唆されている。

* インターフェイスを用いて設計する。
* 継承よりもオブジェクトの集約を多用する。
* 流動的要素を見つけ出して、それをカプセル化する。

### 6章 Facadeパターン

* 目的：既存システムの使用方法を簡素化したい。独自のインターフェイスを定義する必要がある。
* 問題：複雑なシステムの一部だけを使用する必要がある。あるいは、特定の方法でシステムとやり取りする必要がある。
* 解決策：Facadeによって、既存システムを使用するクライアント向けの新たなインターフェイスを作成する。
* 構成要素と協調要素：このパターンは複雑なシステムの使用が容易になるよう、クライアントに対して簡潔なインタ０フェイスを提供する。
* 因果関係：Facadeは要求されたサブシステムの使用方法を簡略化して提供する。しかし、Facadeは全ての機能を提供するものではないため、ある種の機能はクライアントから利用できない可能性がある。
* 実装：必要なインターフェイスをもつ新たなクラスを定義する。この新規クラスから既存のシステムを使用する。

既存システムをFacadeクラスのprivateメンバとして保持することで、Facadeのユーザーに対して既存のシステムを隠蔽、つまりカプセル化することができる。これによりシステムの利用状況を追跡することが容易になり、システムの交換が発生した時の影響を最小限にできる。

### 7章 Adapterパターン

* 目的：修正することのできない既存オブジェクトを特定のインターフェイスに適合させる。
* 問題：使用したいデータや振る舞いが既存システム内に存在しているものの、そのインターフェイスが正しくない場合。通常は抽象クラスから何らかの派生を作成しなければならない場合に使用する。
* 解決策：必要なインターフェイスを保持したラッパをAdapterによって提供する。
* 構成要素と協調要素：Adapterは、Target(派生元クラス)のインターフェースに合うよう、Adapteeのインターフェースを適合させる。これによりClientは、AdapteeをあたかもTarget型であるかのように使用できるようになる。
* 因果関係：Adapterパターンにより、既存オブジェクトをそのインターフェースに制限されることなく、新たなクラス構造に取り込むことが可能になる。

Facadeパターンはインターフェースを簡素化し、Adapterパターンはインターフェースを変換する。

### 8章　視野を広げる

* オブジェクトは操作を伴ったデータではなく、責務を伴った実体である。
責務に着目することで実装の詳細を隠蔽できるようになる。これは将来的に発生する修正が容易に行えることの助けになる。
* 特化のために継承クラスを利用すると親クラスの変更の影響範囲が大きくなり、変化に追随できなくなる。
* 振る舞いにおける流動的要素をオブジェクトとして保持させ、それを使用することで必要となる振る舞いを実行させる。
* 冗長性と結合度は密接に関連しあっており、重複したコードが存在するとその部分の結合度は必然的に高くなる。

#### 練習問題

1. カプセル化についての正しい認識。
データだけではなくあらゆるものの隠蔽を指す。流動的要素を見つけ出してカプセル化することが重要。

1. 問題領域を見る際の三つの観点。
    * 概念：どのような責任を負うか。
    * 仕様：どのように利用されるか。
    * 実装：責任をどうやって果たすか。

### 9章 Strategyパターン

単なる継承ではなく、流動的要素をクラスとして切り出し集約することで変化に対応しやすい設計となる。

* 目的：様々なビジネスルールやアルゴリズムを、それが発生するコンテキストに応じて使い分けられるようにする。
* 問題：要求を行うクライアントや操作対象データによって適用するアルゴリズムを選択する。規則が変化しない場合、Strategyパターンを使用する必要はない。
* 解決策：該当アルゴリズムの実装からアルゴリズムを個別に切り出す。これによりコンテキストによる選択が可能になる。
* 構成要素と協調要素：省略。
* 因果関係
    * Strategyパターンはアルゴリズムのファミリを定義するものである。
    * switch および/あるいは条件分岐をなくすことができる。
    * 全てのアルゴリズムは同じインターフェースとなっている必要がある。
* 実装：アルゴリズムを使用する側のクラスに、該当アルゴリズムの呼び出し方を保持させる（抽象クラスやインターフェース）。それぞれの派生クラスや実装としてアルゴリズムを実装する。

Strategyパターンによって各アルゴリズムを独立したクラスに格納できるため、テスティングのやり取りもインターフェースのみを通じて行えるようになる。よって単体テストが簡素化できる。

### 10章 Bridgeパターン

#### パターンを導き出す

抽象的側面（Shape）と実装（描画プログラム）が緊密に結合している場合はクラス爆発が起きる。
実装を気にすることなく抽象的側面を変更できるようにするためにBrdgeパターンを用いる。

様々な形状を様々な描画プログラムで描画する場合は、ShapeとDrawingが流動的要素としてきりだせる。

* Shape内は形状の概念をカプセル化し、自分の描画方法を知っておくという責務がある。
* Drawingは直線や円を描画するという責務がある。

ShapeがDrawingを保持するという形にすることで、抽象的側面と実装を切り離すことができる。

#### 鍵となる特徴

* 目的：実装を使用しているオブジェクト群から、その一連の実装を切り離す。
* 問題：クラス数の爆発を招くことなく、抽象クラスの派生物から複数の実装を使用する必要がある。
* 解決策：使用する全ての実装のインターフェースを定義し、抽象クラスの派生物からそれらを使用する。
* 構成要素と協調要素：省略。
* 因果関係：オブジェクトが使用している実装を、そのオブジェクトから切り離すことによって、拡張性を高める。クライアントオブジェクトは、実装に関するあれこれを気にする必要がなくなる。
* 実装：
    * 抽象クラス内に実装をカプセル化する。
    （実装のカプセル化には抽象クラスではなく、インターフェースを使用することもできる。）
    * 実装を使用する抽象的側面の基底クラス内に、そのハンドルを保持しておく。

### 11章 Abstract Factory パターン

* 目的：特定のクライアント（または状況）に対するオブジェクトのファミリやセットを用意する。
* 問題：関連のあるオブジェクトのファミリを実体化する必要がある。
* 解決策：オブジェクトのファミリを生成する。クライアントオブジェクトが使用するオブジェクト群の実体化方法に関する規則を、その使用から切り離す。
* 構成要素と協調要素：省略。
* 因果関係：このパターンにより、どのオブジェクトを使用するのかという規則と、それらのオブジェクトの使用方法に関するロジックを分離することができる。
* 実装：
    * 抽象クラスを定義し、作成対象オブジェクト群を規定する。その後、各ファミリ毎に具象クラスを実装する。テーブルやファイルを使用することで同じことを実現することもできる。
    * ファミリ毎に具象クラスを作成したくない場合はコンフィギュレーションファイルを作成し、使用対象オブジェクトを記述しておく。そして、switchを使用してコンフィギュレーションから適切なオブジェクトを実体化する。

### 12章 エキスパートはどのように設計する？

* 一度に一つ：パターンの適用は順に一つずつ行うべきである。
* コンテキスト重視：他のパターンのためのコンテキストを作るようなパターンを最初に適用する。

### 13章 CAD/CAMの問題をパターンによって解決する

以下の手順に従いパターンで考える。

1. パターンの洗い出し
1. パターンの分析・適用
    * パターンの並び替え：コンテキスト重視
    * 並び替えた順に概念設計を行う
    * 追加のパターンの洗い出し
1. 詳細の追加：クラスやメソッド定義の拡張など

### 14章 デザインパターンの原則と戦略

* 開放/閉塞原則：モジュール、メソッド、クラスは拡張性という観点から見た場合は見通しの効くようになっており、変更という観点から見た場合は閉鎖的になっているべきであるということ。
* 依存性の逆転原則：
    * 高次のモジュールは、低次のモジュールに依存してはならない。高次のモジュールと低次のモジュールはいずれも抽象的側面に依存すべきである。
    * 抽象的側面は詳細に依存してはならない。詳細が抽象的側面に依存すべきである。
* オブジェクトを使用する側とされる側の結合は、実装レベルではなく概念レベルで行われるべきである。
* 基底クラスから派生するクラスの存在を、そのクラスを使用する側から隠蔽することで派生クラスを交換可能にする。
* 抽象クラスとインターフェースの表層的な違いは、派生物に共通する状態や振る舞いを保持させるか否か。
設計時にはインターフェースから考え、必要があればインターフェースを実装した抽象クラスを定義する。
* パターンは問題領域に存在しそこから洗いだすのであって、外部から当てはめるのではない。

### 15章 共通性/可変性分析

アプリケーションの設計を行う際には、まず最初に共通性/可変性分析を用いて、問題領域内に存在している概念（共通性）と具体的な実装（可変性）を洗い出す。

1. 最初に共通性を洗い出す。
1. 共通性から抽象的側面を見つけだす。
1. 共通性における流動的要素を用いて派生物を洗い出す。
1. 共通性が互いにどのように関連しているのかを見極める。

### 16章 分析マトリクス

流動的要素を整理するためのツールとして、分析マトリクスというツールがあり表形式で概念を分析する。

### 17章 Decoratorパターン

* 目的：オブジェクトに対して新たな責務を動的に追加する。
* 問題：手元にあるオブジェクトには基本的な機能が用意されているものの、そのオブジェクトの基本機能を実行する前や後に、何らかの追加機能を付加したい場合に使用できる。
* 解決策：サブクラスを作成せずとも、オブジェクトに機能を追加することができる。
* 因果関係：付加する機能は、個々のオブジェクト内に実装される。核となる機能の前後に追加機能を付加できるようになるが、連鎖の実体は常に核となるオブジェクトで終了する。
* 実装：核となる機能を表したクラスとそのクラスに付加する追加機能の双方を表す抽象クラスを作成する。

Decoratorパターンは以下のフォースを解決する。

* 複数の追加機能が存在している。
* 追加機能群が規則に則っているかわからない。
* クライアントに余計なことを考えさせることなく、追加機能を特定の順序で付加する仕組みが必要である。
* どの追加機能を使用しているのか、あるいはその存在自体をアプリケーション側に意識させたくない。

Decoratorは後続オブジェクトを包み込む（コンストラクタで保持する）。

### 18章 Observerパターン

デザインパターンは以下に分類される。

* 生成：オブジェクトの生成や実体化
* 構造：既存オブジェクトをまとめる
* 振る舞い：柔軟な振る舞いを実現する

さらに分割に関するパターンの典型としてObserverパターンを解説する。
Observerパターンの目的は「オブジェクト間に一対多の依存関係を定義し、あるオブジェクトの状態が変化した際に、それに依存する全てのオブジェクトに対して自動的に通知、更新が行われるようにする」となっている。
ただ、依存関係が常に決まっている場合はObserverパターンは必要ない。

* 目的：オブジェクト間に一対多の依存関係を定義し、あるオブジェクトの状態が変化した際に、それに依存する全てのオブジェクトに対して自動的に通知、更新が行われるようにする。
* 問題：変化する一連のオブジェクトに対して、あるイベントが発生したことを通知する必要がある。
* 解決策：オブザーバは観察対象がイベントの監視を一括して行えるように、その監視義務を委譲する。
* 構成要素と協調要素：オブザーバは自らを観察対象に登録するため、観察対象はオブザーバの存在を知っている。特定のイベントが発生した際、観察対象は全てのオブザーバに通知を行う必要がある。オブザーバの責務は観察対象に対する自らの登録と、通知の際における観察対象からの情報取得である。
* 因果関係：オブザーバがイベントの一部にしか興味を持っていない場合でも、観察対象はオブザーバに対して通知を行う可能性がある。
* 実装：イベントの通知先オブジェクト（Observer）を用意し、イベントの発生を監視している、あるいはイベント自体を発生させるオブジェクト（Subject）に自らを登録させる。イベント発生時、SubjectはObserverにイベントの発生を通知する。オブザーバとなる全てのオブジェクトにObserverインターフェースを実装するため、Adapterパターンが使用されることもある。

### 19章 Template Method パターン

* 目的：ある操作におけるアルゴリズムの骨格を定義し、いくつかの処理の定義についてはサブクラスに任せる。そして、アルゴリズムの構造を変化させることなく、その中に含まれる処理の再定義を行う。
* 問題：一定レベルで整合性のある手続きや一連の手順が存在するものの、個々の処理が詳細レベルで異なった実装になる可能性がある。
* 解決策：整合性のある基本手続きを維持した状態で、変化する処理部分を定義できるようになる。
* 因果関係：テンプレートによって、コードを再利用する際のプラットフォームが提供される。また、抽象メソッドを宣言しておくことで、必要となる処理の実装を強制させることも可能である。テンプレートは、派生クラスがオーバライドした処理をまとめ上げ、これらの流動的要素が常にまとめられた形で実行されるようにする。
* 実装：抽象クラスを作成し、手順を実装し、抽象メソッドを宣言する。これらの抽象メソッドは、手順中の各処理を実行するよう、サブクラスにて実装する必要がある。

### 20章 生成に関するパターンから得られる教訓

### 指針に従ったファクトリ

オブジェクトの動作方法とオブジェクトの生成規則を切り離すという観点から、開発を二つの手順に分割するアプローチが考えられる。

1. オブジェクトと、その動作方法を定義する。
1. 適切な状況下で適切なオブジェクトを実体化し、それらオブジェクトが共有される場合は管理を行うファクトリを開発する。

手順1ではオブジェクトがどのように実体化されるかについて関知せず、手順2では実体化したオブジェクトがどのように動作するか関知しない。
これらの関心ごとを分けることで、特定のクラス内ではどちらか一方を扱えば済むようになる。
下記の規則に従うことで、責務を明確に分割して結合度を下げることができる。
* 「オブジェクトは、他のオブジェクトを生成あるいは管理するか、他のオブジェクトを使用するかのどちらかのみを行い、双方を行ってはならない。」

### ファクトリの様々な役割

* ファクトリはどのオブジェクトを生成するのかという規則の他に、どのように管理するのかという規則も関知しておくべきである。こういった規則には実体化するオブジェクトの数や順序、共有方法といったものが含まれる。
* オブジェクト群を生成し、それを組み込んでいくという過程をファクトリで隠蔽し、使用側からは複雑なロジックが存在しないかのようにカプセル化できる。

### 21章 Singleton パターン

* 目的：オブジェクトの同一インスタンスを、参照を引回すことなく使用させたい。
* 問題：複数のクライアントオブジェクトから同じものを参照する必要があり、かつ二つ以上の実体が生成されて欲しくない。
* 解決策：インスタンスの単一性を保証する。
* 構成要素と協調要素：クライアントは、getInstanceメソッドによってのみSingletonのインスタンスを生成する。
* 因果関係：クライアントはSingletonのインスタンスが存在しているかどうか気にする必要がなくなる。
* 実装：
    * オブジェクトを保持するためのメンバ（privateかつstatic）をクラスに追加する。
    * 上記メンバに設定された値を返す、publicかつstatic属性の設定されたメソッドを追加する。なお、メンバがnullの場合は該当クラスの実体化を行う。
    * 直接インスタンス化されないように、コンストラクタは明示的にprivateもしくはprotectedに設定する。

Singletonはマルチスレッド環境では正しく動作しない可能性がある。
その場合は同期化などを含んだDouble-Checked Lockパターンが利用される。

### 22章 Object Pool パターン

理解できなかったので省略。

### 23章 Factory Method　パターン

* 目的：オブジェクト生成用のインターフェースを定義するものの、実体化するクラスの決定はサブクラスに任せる。Factory Method パターンを使うことで、クラスは実体化に関する決定をサブクラス実装時まで保留することができる。
* 問題：クラスは他のクラスの派生物を実体化する必要があるものの、どれを実体化するかわかっていない。
* 解決策：派生クラス側で、実体化するクラスとその実体化方法を決定する。
* 実装：
    * 抽象クラスにオブジェクトのファミリを生成するメソッドを定義する。
    * 必要となるファミリごとに派生クラスを作成し、生成メソッドをオーバーライドする。

### 24章 ファクトリのサマリ

* システムの規模が小さく、複雑さが少ししかない場合、ファクトリは単にオブジェクトの生成を行うメソッドとして表現できる。
* その後、複雑さが増して行けば、様々な規則をハードコーディングした具体的なファクトリ/管理オブジェクトに発展させることができる。
* 最終的にはコンフィギュレーションファイルやデータベースを用いることで、柔軟な規則を取り扱えるようにすることもできる。

### 25章 デザインパターンのおさらい：総括と今後

* 共通性/可変性分析を用いた共通性の洗い出しによって、問題領域に存在しているパターンを洗い出す際の手がかりが得られる。概念上の観点（共通性）と実装上の観点（特定の流動的要素）を洗い出すことができる。
* 共通性とそれらを利用するオブジェクトを考慮するだけで、問題領域を責務の分割ということなった観点から捉えられるようになる。
* パターンそのものが重要なのではなく、パターンによって、特定のコンテキストにおける特定の問題についてのフォース、動機、関連を描写することができ、また、こういった関心ごとに対するアプローチが示されることが重要。
* パターンを見るときには以下の観点に立って考察するのが良い。
    * 何をカプセル化するのか？
    * どのようにして共通性/可変性分析を用いるのか？
    * どのようにして問題領域を責務に分解するのか？
    * どのようにしてオブジェクト間の関連を規定するのか？
    * どのようにしてコンテキストに基づく設計を浮き彫りにするのか？
