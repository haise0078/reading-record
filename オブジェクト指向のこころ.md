## 1部 オブジェクト指向ソフトウェア開発入門

### 1章 オブジェクト指向パラダイム

* 機能分解によってメインプログラムの責務が大きくなりすぎることを防ぐために、委譲という考え方を用いる。
委譲とは、実行指示をすれば各々が責務にしたがって振る舞うこと。
* 機能分解によってモジュール化されたソフトウェアは凝集度が低く、結合度が高くなる。
結果、要求の変化に対応する際のコストが増大し、バグが生み出されやすくなる。
* カプセル化は単にデータの隠蔽ではなく、実装や具象クラスの型などあらゆる種類の隠蔽である。
カプセル化は結合度を下げることに繋がり、実装側と呼び出し側を切り離して修正できるようになる。
* ポリモーフィズムを実現することで、柔軟なソフトウェアを構築できる。

#### 練習問題

1. 機能分解の基本的なアプローチ：手順を詳細に分解してモジュール化する
2. 要求の変更：

    * ユーザーが新たな可能性に気づく
    * 開発側の理解が深まり、考え方が変わる
    * 環境が変化する

3. 責任に着目することの意味：責任に着目することで、リクエストを出す際には責任を知っておけばよく、実装をカプセル化できる
4. 結合度と凝縮度の定義：

    * 凝集度はあるルーチン内の演算の関連の強さを表す
    * 結合度はあるルーチンと他のルーチンの関連の強さを表す

5. インターフェイスの目的：他のオブジェクトに利用方法を提示する、同じ概念を持つオブジェクトの仕様を共通化する
6. インスタンスの定義：そのクラスの型に従い作成される新規オブジェクト
7. オブジェクトが定義する三つの観点：

    * 概念：何に対する責任を持つのか
    * 仕様：どのように使用されるのか
    * 実装：どのようにして責任を全うするのか

8. 抽象クラスとは？：抽象クラスは実体化できないだけではなく、それが表現する概念を具体化したクラスの実装を格納する場所を提供する
9. オブジェクトが保持できるアクセス可能性：public, protected, private
10. カプセル化の定義：データや実装など、あらゆる種類の隠蔽
11. ポリモーフィズム：同一の仕様に沿った呼び出し方法で、異なる実装のクラスを呼び出し振る舞いを変えること
12. オブジェクトを考える際の三つの観点：概念、仕様、実装

### 2章 UML統一モデリング言語

クラスの関係は以下の通り。

* 継承（is a 関係）

    ある抽象クラスAから派生したBは　B is A という継承関係にある。

* 集約（has a 関係）
    
    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成しない場合。

* コンポジション（has a 関係）

    あるクラスが別のクラスを保持する関係で、オブジェクトを保持しているものが、そのオブジェクト自体を構成する場合。

* 依存（use a 関係）
  
    あるオブジェクトが別のオブジェクトを使用する関係。

## 練習問題

1. 関係：省略
2. クラス表現の3つの内容：名称、データメンバ、メソッド
3. ガーディナリティ：いくつ保持するかを表す
4. シーケンス図の目的：オブジェクト間の動的なやり取りを時系列で可視化して定義すること

## 2部 従来のオブジェクト指向設計における限界

### 3章

エキスパートシステムが異なるバージョンのCAD/CAMシステムに対応できるようにする必要があった。

### 4章

あらゆるケースを特殊化するアプローチで、問題を解決することは可能である。
しかしこの設計は冗長度が高く、凝集度が低く、将来の変更時にクラス数が爆発するという欠点がある。

## 3部 デザインパターン

### 5章 デザインパターンの紹介

デザインパターンを学習することで下記のメリットがある。

* 解決策の再利用：すでに確立されている設計を再利用することで、問題解決に向けて幸先のようスタートを切ることができる。
* 共通用語の確立：コミュニケーションを円滑にするために、問題に対する共通のボキャブラリと認識を保つことができる。

優れたオブジェクト指向設計を生み出すための戦略として下記が示唆されている。

* インターフェイスを用いて設計する。
* 継承よりもオブジェクトの集約を多用する。
* 流動的要素を見つけ出して、それをカプセル化する。

### 6章 Facadeパターン

* 目的：既存システムの使用方法を簡素化したい。独自のインターフェイスを定義する必要がある。
* 問題：複雑なシステムの一部だけを使用する必要がある。あるいは、特定の方法でシステムとやり取りする必要がある。
* 解決策：Facadeによって、既存システムを使用するクライアント向けの新たなインターフェイスを作成する。
* 構成要素と協調要素：このパターンは複雑なシステムの使用が容易になるよう、クライアントに対して簡潔なインタ０フェイスを提供する。
* 因果関係：Facadeは要求されたサブシステムの使用方法を簡略化して提供する。しかし、Facadeは全ての機能を提供するものではないため、ある種の機能はクライアントから利用できない可能性がある。
* 実装：必要なインターフェイスをもつ新たなクラスを定義する。この新規クラスから既存のシステムを使用する。

既存システムをFacadeクラスのprivateメンバとして保持することで、Facadeのユーザーに対して既存のシステムを隠蔽、つまりカプセル化することができる。これによりシステムの利用状況を追跡することが容易になり、システムの交換が発生した時の影響を最小限にできる。

### 7章 Adapterパターン

* 目的：修正することのできない既存オブジェクトを特定のインターフェイスに適合させる。
* 問題：使用したいデータや振る舞いが既存システム内に存在しているものの、そのインターフェイスが正しくない場合。通常は抽象クラスから何らかの派生を作成しなければならない場合に使用する。
* 解決策：必要なインターフェイスを保持したラッパをAdapterによって提供する。
* 構成要素と協調要素：Adapterは、Target(派生元クラス)のインターフェースに合うよう、Adapteeのインターフェースを適合させる。これによりClientは、AdapteeをあたかもTarget型であるかのように使用できるようになる。
* 因果関係：Adapterパターンにより、既存オブジェクトをそのインターフェースに制限されることなく、新たなクラス構造に取り込むことが可能になる。

Facadeパターンはインターフェースを簡素化し、Adapterパターンはインターフェースを変換する。

### 8章　視野を広げる

* オブジェクトは操作を伴ったデータではなく、責務を伴った実体である。
責務に着目することで実装の詳細を隠蔽できるようになる。これは将来的に発生する修正が容易に行えることの助けになる。
* 特化のために継承クラスを利用すると親クラスの変更の影響範囲が大きくなり、変化に追随できなくなる。
* 振る舞いにおける流動的要素をオブジェクトとして保持させ、それを使用することで必要となる振る舞いを実行させる。
* 冗長性と結合度は密接に関連しあっており、重複したコードが存在するとその部分の結合度は必然的に高くなる。

#### 練習問題

1. カプセル化についての正しい認識。
データだけではなくあらゆるものの隠蔽を指す。流動的要素を見つけ出してカプセル化することが重要。

1. 問題領域を見る際の三つの観点。
    * 概念：どのような責任を負うか。
    * 仕様：どのように利用されるか。
    * 実装：責任をどうやって果たすか。

### 9章 Strategyパターン

単なる継承ではなく、流動的要素をクラスとして切り出し集約することで変化に対応しやすい設計となる。

* 目的：様々なビジネスルールやアルゴリズムを、それが発生するコンテキストに応じて使い分けられるようにする。
* 問題：要求を行うクライアントや操作対象データによって適用するアルゴリズムを選択する。規則が変化しない場合、Strategyパターンを使用する必要はない。
* 解決策：該当アルゴリズムの実装からアルゴリズムを個別に切り出す。これによりコンテキストによる選択が可能になる。
* 構成要素と協調要素：省略。
* 因果関係
    * Strategyパターンはアルゴリズムのファミリを定義するものである。
    * switch および/あるいは条件分岐をなくすことができる。
    * 全てのアルゴリズムは同じインターフェースとなっている必要がある。
* 実装：アルゴリズムを使用する側のクラスに、該当アルゴリズムの呼び出し方を保持させる（抽象クラスやインターフェース）。それぞれの派生クラスや実装としてアルゴリズムを実装する。

Strategyパターンによって各アルゴリズムを独立したクラスに格納できるため、テスティングのやり取りもインターフェースのみを通じて行えるようになる。よって単体テストが簡素化できる。

### 10章 Bridgeパターン

#### パターンを導き出す

抽象的側面（Shape）と実装（描画プログラム）が緊密に結合している場合はクラス爆発が起きる。
実装を気にすることなく抽象的側面を変更できるようにするためにBrdgeパターンを用いる。

様々な形状を様々な描画プログラムで描画する場合は、ShapeとDrawingが流動的要素としてきりだせる。

* Shape内は形状の概念をカプセル化し、自分の描画方法を知っておくという責務がある。
* Drawingは直線や円を描画するという責務がある。

ShapeがDrawingを保持するという形にすることで、抽象的側面と実装を切り離すことができる。

#### 鍵となる特徴

* 目的：実装を使用しているオブジェクト群から、その一連の実装を切り離す。
* 問題：クラス数の爆発を招くことなく、抽象クラスの派生物から複数の実装を使用する必要がある。
* 解決策：使用する全ての実装のインターフェースを定義し、抽象クラスの派生物からそれらを使用する。
* 構成要素と協調要素：省略。
* 因果関係：オブジェクトが使用している実装を、そのオブジェクトから切り離すことによって、拡張性を高める。クライアントオブジェクトは、実装に関するあれこれを気にする必要がなくなる。
* 実装：
    * 抽象クラス内に実装をカプセル化する。
    （実装のカプセル化には抽象クラスではなく、インターフェースを使用することもできる。）
    * 実装を使用する抽象的側面の基底クラス内に、そのハンドルを保持しておく。

