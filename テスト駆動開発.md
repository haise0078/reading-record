# テスト駆動開発

## 多国通貨
### 1. 仮実装

実装のサイクルは次の通り。

1. 小さいテストをひとつ書く。
1. 全てのテストを実行し、ひとつ失敗することを確認する。
1. 小さい変更を行う。
1. 再びテストを実行し、全て成功することを確認する。
1. リファクタリングを行い、重複を除去する。

仮実装はコードでまずベタ書きの値を使い、実装を進めるにしたがって変数に置き換えること。

### 2. 明白な実装

明白な実装は頭の中で正しいと思った実装を、すぐにコードに落とすこと。
TDDを行うときは仮実装と明白な実装を行き来しながら開発を進める。

### 3. 三角測量

三角測量は、2つの観点でのテストを同時に通すリファクタリングを行うこと。

### 4. 意図を語るテスト

テストの意図が読み取りやすいようにコーディングする。

### 5. 原則をあえて破るとき

テストが失敗することの確認までは速度重視で、設計の原則を無視しても構わない。
ただし、リファクタすることが前提である。

### 6. テスト不足に気づいたら

リファクタでテスト不足に気づいたら、即座にテストを追加する。

### 7. 疑念をテストに翻訳する

疑念はテストとして表現し、一旦は仮実装でテストを通して放置しても良い。

### 8. 実装を隠す

Factory Methodパターンを用いて、テストコードからサブクラスの実装を隠した。

### 9. 歩幅の調整

TDDでは変更の歩幅（大きさ）を常に微調整する。
細かなステップがやりすぎな場合は歩幅を大きくして、修正に不安を感じるなら歩幅を小さくする。

### 10. テストに聞いてみる

* デバッグ用の処理を実装する場合は、テストを書かずにコードを書いても良い。
* 新しい変更を試して、テストに動くかどうかを聞いてみる。
* テストがレッドバーでプロダクトコードを修正したい場合は、一旦テストをグリーンにしたほうがいい。
そのあとに、プロダクトコードの修正に対するテストを書いてから修正を始める。

### 11. 不要になったら消す

プロダクトコードの修正などで冗長になったテストは削除する。

### 12. 設計とメタファー

式のメタファーを使って通貨を足し合わせる責務を分離した。

### 13. 実装を導くテスト

必要なオブジェクトの実装を促すテストを作成する。これは一時的なテストであっても問題ない。
このテストを通すために、コンストラクターのみでも問題ないので必要なオブジェクトを実装して先に進んでいく。

### 14. 学習用テストと回帰テスト

* 言語仕様などを確認するために一時的な学習用テストを書くこともある。
* リファクタリング中に想定外の要件が発覚した場合は回帰テストを実装する。
* 実装内部で使うだけのヘルパークラスは個別のテストがなくても、他の実装のテストで担保される。

### 15. テスト任せとコンパイラ任せ

テストが通っておらず変更が連鎖的な場合は二つの道がある。

* テストの抽象度を落として修正の複雑さを下げる。
* コンパイラを信じて連鎖的な変更を順番に処理していく。

### 16. 将来の読み手を考えたテスト

テストには将来の仲間に仕様を伝えるという役割もある。
そのため、テストを書くときには意図が伝わりやすくなる書き方を意識するのが良い。

### 17. 多国通貨の全体の振り返り

* TODOを消化したらコードを批判的にみて、重複がある場合は設計を見直したりする。
* 「こう動いてはならない」というテストを追加することも考える。意図せぬ挙動が発見されたりするからだ。
* TDDによって作成されるテストは以下のテストの代替にはならない。
    * パフォーマンステスト
    * 負荷テスト
    * ユーザビリティテスト

## xUnit

### 18. xUnitへ向かう小さな一歩

小さいステップで開発するのは大事だよ的な。

### 19. 前準備

テストを書くときには次のステップがある。

1. 準備：オブジェクトを作る。
1. 実行：オブジェクトを操作する。
1. アサート：結果の検証を行う。

準備の段階は異なるテストでも重複している。
できるだけ重複を無くしたいが、ここで相反する制約が現れる。

* パフォーマンス：オブジェクトを使い回してテストをできるだけ早くしたい。
* 独立性：テスト間の依存関係をなくす必要がある。

オブジェクトの生成が十分早い場合には独立性を重視してテストを作成する。
今回オブジェクトの生成用のメソッドを用意して、テスト毎に呼び出すことにした。

### 20. 後片付け

テストの後片付けのためのtearDownメソッドを実装した。

### 22. 失敗の扱い

テストの例外をキャッチしてカウントするように修正した。
setUpメソッドの例外を扱えていないことに気づき、TODOリストに追加した。

### 23. スイートにまとめる

複数のテストを独立して同時に実行して、まとめた結果を得るためにテストスイートを用意する。
Collecting Parameterパターンを用いて、テスト結果を収集するようにした。

## テスト駆動開発のパターン

### 25. テスト駆動開発のパターン

* テストは自動的に実行されるように開発フローに組み込むこと。
* テストは独立して他のテストに影響を与えないこと。
* TODOリストにやるべきことを全て書き出してから、コーディングを始めること。
* テスト対象のコードを書くまえにテストを書くこと。

### 26. レッドバーのパターン

* はじめに書くテストは以下のような特徴を満たすと、フィードバックループを小さくできる。
はじめのテストは抽象度の高くアプリケーションに近いものになるかもしれない。
    * 出力と入力が完全に一致する。
    * 入力が可能な限り小さいもの。

* 初めてソフトウェアを触る際には、学習用のテストを書いて想定通りに動くか検証するのもいい。
* 不具合報告があれば、回帰テストを実装する。回帰テストは本来はコードを書いたときに同時に実装されるべきだったテスト。

### 27. テスティングのパターン

* 大きいテストが失敗したら問題箇所を絞り込んで、小さいテストをかく。
* 構築処理に時間がかかるオブジェクト、例えばデータベースなどは代わりにモックオブジェクトを活用する。
* メソッドの実行順序をテストしたい場合は、文字列に記録してテストする。
* エラー処理をテストしたい場合は通常と異なるオブジェクトを渡して、テストからメソッドを叩く。
* コーディングはテストが失敗した状態で中断すると、再開するときに何から手を付けるかが分かりやすい。

### 28. グリーンバーのパターン

* 仮実装としてベタ書きの値を使い、本実装として重複を置き換える。
早めにグリーンバーに辿り着くことで、自分が進んでいることを確認できる。
* テストの一般化の最も慎重な方法が三角測量になる。
* 実装が明白な時は、仮実装や三角測量はスキップできる。
* コレクションを扱う時は、まず単数で実装してからコレクションにしていく。

### 29. xUnitのパターン

繰り返しなので省略。

### 30. デザインパターン

* Command

    処理の実行を表現するオブジェクトを作成し、パラメータを渡して処理の実行を任せる。

* Template Method
    
    処理（メソッド呼び出し）の順序を表現するオブジェクトを作成し、ルールの重複を防ぐ。

* Pluggable Object
    
    条件分岐を担うオブジェクトを作成し、if文の氾濫を防ぐ。

* Factory Method
    
    オブジェクトを作成するメソッドを実装することで、オブジェクト作成に柔軟性を持たせる。

* Imposter
    
    定義がわからない。

* Composite
    
    再帰的なデータ構造を扱うクラスを実装することで、オブジェクトの集合をまとめて扱えるようにする。

### 31. リファクタリング

* 重複をなくすためにゴールから逆算して差異を減らしていく。
* メソッドの中で複雑な処理や再利用される処理は、独立したメソッドに分離できる。
* メソッドの分離の逆がインライン化という。メソッドの呼び出し側にメソッドの処理を記述することを指す。
* 他のオブジェクトに対して多数のメッセージを送っている場合、メソッドをそのオブジェクトに移動させることも考える。
* メソッドの分離に向かない場合は、メソッド自体をクラスとして切り出すことを考える。

### 32. TDDを身に着ける

#### いいテストを見分けることができるか

テストは設計のカナリアとして役立つ。設計に問題がある場合は下記のような兆候が現れる。

* 前準備に要するコードが長い：

    オブジェクトが大きすぎるので分割が必要。

* 前準備のコードの重複：
    
    共通の前準備コードを配置する場所がすぐに見つからないのは、互いに密に関連し合うオブジェクトが多すぎることを示唆している。

* テスト実行時間が長い：
    
    テストスイートの実行に10分間以上かかる場合は、テストサイクルに悪影響があるので、テストを削減したりアプリケーションを高速化したりする必要がある。

* 脆いテスト：

    思わぬところで失敗するテストは、アプリケーションに意図せぬ依存関係がある可能性を示唆している、
    依存関係を断つか、統合するなどして、離れた箇所からの影響を排除する必要がある。

#### どのようなときにテストを消すべきか

重複があり、下記に当てはまらないなら削除してしまおう。

* テストを消すことでシステムの振る舞いに対する自身が減るならテストを削除してはならない。
* テストがコードの同じ部分を実行しているとしても、テストの読み手には異なるシナリオと映るのであれば消さずにそのままにしておく。

#### 途中からTDDを導入するには

全体をテスト駆動開発に置き換えようとすると、膨大なコストがかかる。
頻繁に変更が必要な部分にのみTDDを適用していくことで、費用対効果を高くTDDを導入できる。
