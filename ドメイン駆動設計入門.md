# ドメイン駆動設計入門

## 1. ドメイン駆動設計とは

ソフトウェア開発におけるドメインは、「プログラムを適用する対象となる領域」を指す。
ソフトウェアがその責務を全うするためにドメインに必要な情報を抽出して抽象化したものをドメインモデルと呼ぶ。
ドメインモデルをソフトウェアで動作するモジュールとして表現したものがドメインオブジェクトとなる。
ドメインで変化があれば、その変更はドメインモデルに反映され自ずとドメインオブジェクトも変更される。これにより反復的な開発が実現される。

## 2. システム固有の値を表現する「値オブジェクト」

プリミティブな値とその値のルールを合わせ持つオブジェクト。

そもそも値は以下のような性質を持つ。値オブジェクトはこれらの性質を引き継ぐ。
* 不変であると同時に交換可能である。
値は不変であるが、代入によって交換することが可能。
* 等価性によって比較される。

値についてのルールを値オブジェクトに集約できるメリットがある。
これにより、ルールの変更箇所が一箇所で全体に適用できる。

値オブジェクトにする必要があるかの判断基準は、「ルールが存在するか」と「それ単体で取り扱いたいか」になる。

値オブジェクトを使うモチベーションは以下の通り。
* クラスの定義を参照することで、その値がどういったものかを理解しやすくなる。
* 不正な値を存在させない。
* 型付けにより誤った代入を防ぐ。
* ロジックの散在を防ぐ。

## 3. ライフサイクルのあるオブジェクト「エンティティ」

エンティティは属性ではなく、同一性によって識別されるオブジェクトである。
エンティティの性質は以下の通り。

* 属性が可変である。
* 同じ属性であっても区別される。
* 同一性（一意な識別子）によって区別される。

エンティティになるかどうかに、そのオブジェクトがライフサイクルを持つかどうかという基準がある。生成されたのち、しばらく利用され、削除されるような概念の場合はエンティティが適している。

## 4. 不自然さを解決する「ドメインサービス」

エンティティや値オブジェクトに記載すると不自然になる振る舞いをドメインサービスとして記述する。
例えばユーザーの重複確認をUserオブジェクトに実装すると、ユーザー自身が重複を確認するという違和感のある振る舞いになる。UserServiceにドメインサービスとして重複確認を実装すれば、振る舞いとしての違和感を解消できる。

ドメインサービスは濫用せず、できる限りドメインオブジェクトにルールを集める。

また、あくまでドメインのルールを表現するために必要なのがドメインサービスであり、アプリケーションの作成で必要なサービスはアプリケーションサービスである。

## 5. データにまつわる処理を分離する「リポジトリ」

データの永続化についての処理を分離する。
インターフェイスを活用して、インフラストラクチャ層の技術基盤をドメイン層から隠蔽する。

またインターフェイスを活用してリポジトリを依存注入可能に設計しておくことで、テストの際にモックの活用が容易となる。

## 6. ユースケースを実現する「アプリケーションサービス」

アプリケーションのユースケースを表現するオブジェクト。
ユースケースの例としてはアプリケーション利用者向けのユーザ機能におけるCRUD処理が挙げられる。

アプリケーションサービスは実際のアプリケーションのユースケースを満たすように、ドメインサービスやリポジトリを呼び出す。

このとき、ドメインオブジェクトがパブリックになると、アプリケーションサービス以外のプログラムによって変更されてしまう可能性がある。これはロジックの散在が起きることになる。
それを防ぐためにデータ転送オブジェクトを用意し、ドメインオブジェクト自体を隠蔽する。アプリケーションサービスのクライアントに直接ドメインオブジェクトを渡さず、データ転送オブジェクトを渡すことで、ドメインオブジェクトの操作が散財することを防ぐことができる。

コマンドオブジェクトを用いて、パラメータが変化してもアプリケーションサービスのメソッドのシグネチャは変化しないようにできる。
アプリケーションサービスのメソッドがコマンドオブジェクトを引数として受け取り、コマンドオブジェクトの内容で処理を分岐する。
コマンドオブジェクトを作成することでアプリケーションサービスの処理を制御できるので、コマンドオブジェクトは処理のファサードと言える。

アプリケーションサービスにドメインのルールが記述されることがないようにする必要がある。
またサービスはステートレスであることにも注意が必要。状態によって自身の振る舞いが変化することは基本的にはない。

## 7. 柔軟性をもたらす依存関係のコントロール

### 依存関係の逆転

アプリケーションサービスがリポジトリのインターフェイスに依存するようにして依存関係を逆転することで、ビジネスロジックを具体的な実装に依存させないようにできる。これが依存関係逆転の原則として下記のように定義されている。

* 上位レベルのモジュールは下位レベルのモジュールに依存してはならない、どちらのモジュールも抽象に依存すべきである。
* 抽象は、実装の詳細に依存してはならない。実装の詳細が抽象に依存すべきである。

これにより例えばデータストアの変更を理由にビジネスロジックの習性が必要になるといったことが発生しなくなる。

### 依存関係のコントロール

* ServiceLocator
ServiceLocatorにインスタンスを登録することで、依存関係を解決する。
依存関係が外部から見えずらい、テストの維持が難しくなることからアンチパターンとされる。
* DI Container
依存解決の設定を登録しておくことで、インターフェイスへの依存が解決されインスタンスが生成される。

## 8. ソフトウェアシステムを組み立てる

ユーザーインターフェイスを交換可能にすることで、ユニットテストが実施可能になる。

## 9. 複雑な生成処理を行う「ファクトリ」

複雑なオブジェクトの生成処理をオブジェクトとして定義することで、凝集度を高めたりカプセル化を実現できる。この生成を責務とするオブジェクトを「ファクトリ」と呼ぶ。
ファクトリのインターフェイスを定義しておけば、プロダクションコードでは採番テーブルを参照し、テストコードでは適当なIDをプログラムで生成するように切り替えることもできる。

ファクトリとしてクラスを実装する以外に、メソッドをファクトリとして利用することも考えられる。オブジェクトの内部データを利用してインスタンスを生成する必要があるときに利用され、内部データを公開せずにインスタンスを生成可能にする。

## 10. データの整合性を保つ

データの整合性を保つために以下のような手段がある。
それぞれを組み合わせて整合性を保つことが重要。

* 重複チェックをドメインのルールとして実装する。
* データベースのユニークキー制約を活用する。
* トランザクションによる防衛。

## 11. アプリケーションを1から組み立てる

ドメインルールの流出は修正の難易度を引き上げ、バグが生み出される原因となる。

## 12. ドメインのルールを守る「集約」

### 12.1 集約とは

OOPでは複数のオブジェクトがまとめられて、一つの意味を持ったオブジェクトが構築される。こうしたオブジェクトのグループには維持されるべき不変条件が存在する。

不変条件を維持するためにはオブジェクトの操作に秩序をもたらす必要がある。
そのために不変条件を維持する単位として「集約」を切り出し、外部から集約への操作は全て集約ルートという特定のオブジェクトを経由するようにする。

例えば、UserNameを直接操作していいのはUserという集約のルートであるUserクラスのみである。

これらの原則はデメテルの法則としても知られている。
デメテルの法則によると、オブジェクトO上のメソッドMを呼び出すオブジェクトは次の4つに限定されている。

* オブジェクトO自身
* Mの引数として渡されたオブジェクト
* Mの内部でインスタンス化されたオブジェクト
* Oを直接的に構成するオブジェクト（Oのインスタンス変数）

デメテルの法則は簡潔に言えば「直接の友達とだけ話すこと」であり、各オブジェクトが最小の知識を持つように適切にカプセル化を行うことでロジックが散在することを防ぐ。

### 12.2 集約をどう区切るか

集約は変更の単位で区切る。
永続化の依頼も集約ごとに行われる必要があり、リポジトリは集約の単位で作成するべきである。

また直接オブジェクトを保持する代わりに識別子を保持することで、集約違反を予防することができる。
識別子だけを公開することでビジネスルールが流出することはなく、得られるメリットの方が大きくなる。

## 13. 複雑な条件を表現する仕様

仕様はあるオブジェクトがある評価基準に達しているかを判定するオブジェクトである。
エンティティや値オブジェクトがリポジトリを操作すると、ドメインモデルの表現とは関係のなりコードが増加する。
それを避けるために仕様というオブジェクトを利用する。
例えば、サークルが満員かどうかの判断を仕様として切り出すことで、サークル自身のモデルをコード上で分かりやすく表現できる。

またおすすめサークルの抽出などでは仕様をリポジトリに引き渡して検索処理をすることができる。
このときに仕様のインターフェイスをリポジトリに渡すことで抽象に依存させることで、リポジトリにルールが流出することが防げる。
だが、クエリのパフォーマンスの最適化が難しい点には注意が必要。

パフォーマンスを起因とする懸念がある場合には、ドメインルールの流出を許容することも考えられる。
読み取り（クエリ）ではドメインロジックはあまり関係ないので、クエリ側で最適化することを許容し、書き込み（コマンド）では厳密にドメインを隔離するのが良い。

## 14. アーキテクチャ

### レイヤードアーキテクチャ

レイヤードアーキテクチャは下記の層で構成される。
原則として上位のレイヤーは自身より下位のレイヤーに依存することが許される。
ただし、ドメイン層がインフラ層のオブジェクトを扱うことは意味せず、ドメイン層はインフラ層のインターフェイスに依存する。

* プレゼンテーション層（ユーザーインターフェース層）
表示と解釈を担当。UIとアプリケーションが値をやり取りするためのレイヤー。
* アプリケーション層
* ドメイン層
* インフラストラクチャ層
技術的な基盤へのアクセスを提供する。

### ヘキサゴナルアーキテクチャ

六角形をモデルとしたアーキテクチャでレイヤードアーキテクチャと依存関係は変わらない。
レイヤードアーキテクチャとの違いは、インターフェースを利用した依存関係の整理に言及している点。
各層のインターフェイスのみを定め、層ごとに実体を入れ替え可能にする。

### クリーンアーキテクチャ

ヘキサゴナルアーキテクチャとコンセプトは同じで、ビジネスルールをカプセル化したモジュールを中心に据え、依存の方向を絶対的に制御すること。
実装方法まで詳細に定義されている点がヘキサゴナルアーキテクチャと異なる。

## 15. ドメイン駆動設計の扉を開こう

* 開発者はドメインエキスパートと呼ばれるドメインの精通者たちと会話し、ドメインの概念を正しくソフトウェアに反映しなくてはならない。
ステークホルダーと開発者のやり取りしかないプロジェクトでは、本当に需要を満たせるソフトウェアを生み出すのは難しい。

* ユビキタス言語を策定して、コードにもユビキタス言語を反映すれば理解にかかるコストを削減でき、ドメインの変化がコードに伝わりやすくなる。

* 境界づけられたコンテキストというドメインの国境のようなものがある。
同名のドメインであっても、コンテキストが違えば実装を分けることが必要になる。
この場合はコンテキストマップでモデル同士の関係性を把握する必要がある。
